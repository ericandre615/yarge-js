{"version":3,"file":"renderer2d.js","sourceRoot":"","sources":["../../../src/lib/renderer/renderer2d.js"],"names":[],"mappings":"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","sourcesContent":["import system from '../system.js';\nimport { vertexShader, createFragmentShader } from '../../shaders/batch.js';\nimport createProgram from './program.js';\nimport { createDynamicArrayBuffer, createVertexArray, createElementArrayBuffer } from './buffers.js';\nimport { vertex as createVertex, vertexArray } from './vertex.js';\n\nconst renderState = {\n  program,\n  vertices,\n  indices,\n  layers,\n  vbo,\n  vao,\n  ibo,\n  clearColor,\n  maxTextures,\n  textureSlots,\n  uniforms,\n  sprintCount,\n  renderTarget,\n};\n\nconst batchVertexStruct = {\n  pos: [0, 0, 0],\n  uv: [0, 0],\n  color: [0, 0, 0, 0],\n  texTransform: [0, 0, 0],\n  texScale: [0, 0, 0],\n  texId: [0],\n};\n\nconst generateBatchIndices = max => {\n  let offset = 0;\n  const indices = [];\n\n  // TODO: maybe take in a format or base it off given vertices?\n  // as this needs to match the order of a sprites vertices\n  // this order is more of a top left to bottom right\n  for (let i = 0; i <= max; i++) {\n    let group = [\n      offset + 0,\n      offset + 1,\n      offset + 2,\n      offset + 2,\n      offset + 1,\n      offset + 3,\n    ];\n\n    indices.push(group);\n\n    offset += 4;\n  }\n\n  return indices;\n};\n\nconst DEFAULT_CLEAR_COLOR = [1, 1, 1, 1];\nconst renderer2d = gl => {\n  //let max_index_size = ((::std::mem::size_of::<[u32; 6]>()) * 4000) as gl::types::GLsizeiptr;\n  const maxSprites = 1000; // TODO: just a random value for now\n  const batchVertex = createVertex(gl);\n  const batchVertexLayout = batchVertex(batchVertexStruct);\n  const batchVertexSize = batchVertexLayout.sizeInBytes;\n  const maxBufferSize = batchVertexSize * maxSprites;\n  const maxTextures = system.get_max_textures();\n  const program = createProgram(gl)(vertexShader, createFragmentShader(maxTextures));\n  const uniformTextures = program.getUniformLocation('u_textures');\n  const uniformMvp = program.getUniformLocation('mvp');\n  const textureSlots = Array(maxTextures).fill(0);\n\n  const vbo = createDynamicArrayBuffer(gl);\n  const vao = createVertexArray(gl);\n  const ibo = createElementArrayBuffer(gl);\n\n  const indices = generateBatchIndices(maxSprites);\n\n  vbo.bind();\n  vbo.setBufferData(maxBufferSize);\n\n  vao.bind();\n\n  batchVertexLayout.vertexAttribPointers();\n\n  ibo.bind();\n  ibo.staticDrawData(indices);\n  ibo.unbind();\n\n  vbo.unbind();\n  vao.unbind();\n\n  const state = {\n    maxTextures,\n    textureSlots,\n    spriteCount: 0,\n    drawCalls: 0,\n  };\n\n  return {\n    beginScene: () => {},\n    endScene: () => {},\n    submit: renderables => {\n      const sprites = renderables.length ? renderables : [renderables];\n      if (spriteCount >= maxSprites) {\n        // TODO: need to flush/reset\n        console.log('RENDERER2D: hit maxSprite limit');\n      }\n\n      sprites.forEach(sprite => {\n        const spriteTexture = sprite.texture;\n        const texId = textureSlots.indexOf(spriteTexture);\n      });\n    },\n    render: camera => {\n\n    },\n  };\n}\n\nexport default renderer2d;\n\n"]}